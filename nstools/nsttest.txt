@#; NSTemplate.py 是一个基于 python 的 NS 脚本模板工具
@#; 作者: skydarkchen <skydark2 at gmail>
@#; 发布于公共领域。
@## 直接不带命令行参数执行它可以得到使用帮助。
@## 这篇文档主要介绍其语法特性。这篇文档本身可以被 NSTemplate.py 处理。
@## 另外，这个工具将自动检测文件编码，并将文件转换为适合 NS 的形式，
@## 因此可以用 utf-8 等编码撰写模板文件。

@## --------------------------------------
@## 首先，以 @## 开头的行是注释，不会被输出。
@## 而对于以 @# 开头，紧接着非 # 符号的行，将去掉@#后直接输出，不做其他处理。
@## 下面一些行用 @#; 开头，是为了使得输出也是 NS 的注释。
@#; --------------------------------------
@## 所有 NS 中的变量(%1, $2)等的地址(1, 2)在这里都是*相对*的。
@## 通过指定 @{__base} (即命令行参数中的 --base)可以使所有的变量地址增加 @{__base}
@## 如果命令行参数中不指定 --base，其默认值是1000.

; 示例变量地址偏移:
mov %1, 0

@## 注意: 双引号中包含的变量地址不会被处理
mov $1, "%1"

@#; --------------------------------------
@## 以 @def 开头的行用来定义函数头。
@## 对应的 defsub 指令将在文件末尾自动生成，可以在 NS 的 *define 节用 gosub 调用。

; 示例定义函数
@def test
	测试无参数函数
	return

; 将字符串用$1补齐到至少%3位
; >>> atoaex $1, "xyza", 3, " "
; $1 = "xyza"
; >>> atoaex $1, "x", 3, " "
; $1 = "  x"
@def atoaex s%1, $2, %3, $1
	mov $%1, $2
	len %4, $%1
	if %4 >= %3 return
	sub %3, %4
	for %4 = 1 to %3
		mov $%1, $1+$%1
	next
	return

@#; --------------------------------------
@## 行内使用 @{表达式} 可以表达一些 python 变量。
@## 内嵌支持的 python 变量有:
@##   __base         : 地址偏移基址，即命令行参数传递过去的 --base 参数。
@##  __max_var       : 到当前位置为止读到的最大的变量地址。
@##   __current_name : 当前脚本的名称(默认是文件名去掉后缀)。
@## 注意: 双引号中包含的内嵌表达式不会被处理

; 测试内嵌表达式
mov $1, "@{__base}"
变量%1应该是%@{__base+1}。

@#; --------------------------------------
@## 以 @python 开头的行，其之后连续的以@开头的段落将视为 python 脚本执行。
@## 注： NS 变量的偏移仍然有效，但是注意它们不对双引号内的文本产生影响。
@##      @{}的内嵌语法不再有效。
@## 除了上面列出的 python 变量外，还可以使用下面的函数:
@##   __(s)  : 输出字符串 s. s 中可以使用 {变量名} 嵌入变量值。
@##            注意: @{} 里可以是*表达式*，这里只是*变量名*。
@##            如果需要表达式的值，直接在脚本中计算即可。
@##   __s(s) : 将逗号分隔的字符串 s 切分成数组。

; 测试内嵌 python 脚本
@python
@for name in __s('010203, 110212, 010303'):
@    if name.startswith('0'):
@        __('; if $1="*s{name}" goto *fateroute_controller')
@    else:
@        v = int(__import__('math').sqrt(int(str(__base+1).strip()))**2)
@        __('; mov $1, "%1": mov ${v}, "{name}"')
@__(';@{name}不会以@{{}}的形式解析，因此@依然留了下来')

@#; --------------------------------------
@## 可以使用 @import 导入另一个脚本，其语法为:
@##   `@import 文件名` 或 `@import 文件名 as 名称`
@## 如果不给名称，导入段落的名称默认是文件名(去掉扩展名)。

; 测试导入
@import inner.nst

@## 导入段落的变量是与当前变量分开的，可以如下调用其中的变量:
; 被导入的段落的基址是 @{inner.__base}
@python
@__('; 我的基址仍然是 {__base}, 我的 name 变量值仍然是 {name}')

@#; --------------------------------------
@## 最后一小段测试。

; 分割字符串
; splits与原版split函数不同的是，分割后的右半边是完整的;
; 而rsplits则是从右到左分割的;
; >>> split "a,b,c", ",", $1, $2
; $1 = "a" & $2 = "b"
; >>> splits "a,b,c", ",", $1, $2
; $1 = "a" & $2 = "b,c"
; >>> rsplits "a,b,c", ",", $1, $2
; $1 = "a,b" & $2 = "c"

@def splits $1, $2, s%1, s%2
	split $1, $2, $%1
	len %3, $%1:inc %3
	len %1, $1:sub %1,%3
	if %1<=0 mov $%2,"":return
	mid $%2, $1, %3, %1
	return

@def rsplits $1, $2, s%1, s%2
	split $1, $2, $%1
	if $1 = $%1 mov $%2, "":return
	len %3, $%1
	mov %4, %3+1
	;
	mid $3, $1, %4, 1
	if $3 = $2 mov %3, %4
	if $3 != "" inc %4:skip -3
	mid $%1, $1, 0, %3
	sub %4, %3+1
	mid $%2, $1, %3+1, %4
	return
